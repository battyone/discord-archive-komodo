AuthorID;Author;Date;Content;Attachments;Reactions;
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:11 PM";"Im pretty sure that this is so far.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:12 PM";"see if you can take advantage of the locally validated notarization to make it even more efficient";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:12 PM";"it sounds like you are now making efficient getinfo requests";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:12 PM";"yes it just rotates though the headers from last notarize to tip";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:13 PM";"doesnt stop trying to fetch them, because it must fetch it anyway";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:13 PM";"exactly!";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:13 PM";"and it doesnt need to be any voting based system as all can be validated";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:14 PM";"once it has enough then it can validate the chain tip, that said, once a noa happens it must fetch a heap of them again, I will fix that though doesnt seem hard";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:15 PM";"just shifting the array should work as you should already have up to the chain tip and the new notarization is 5 to 10 blocks behind, but all those headers are alrady there";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:16 PM";"now just need to have reorg detection, which since building the data to chaintip is fast enough, can just reset the headers and start again";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:16 PM";"have a counter for how many times it had to be reset for this notarization and display in the local getinfo";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:16 PM";"when we see this as 1 or more, we know something funny is going on with the chain";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:16 PM";"not sure it needs that tbh, as it saves all the headers it sees, and just  loops backwards from blockhash to block hash, ignoring any that may no longer be in the main chain";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:17 PM";"i guess even over a full day, RAM usage would only be 2MB. i was thinking of using fixed size buffer to limit ram usage";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:17 PM";"I wish it could loop forwards form a notarizations, but you just cant üò¶";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:18 PM";"I clears them after a notarization";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:18 PM";"shouldnt use much at all, one sec I'll check it";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:19 PM";"aha! yes, all the block headers between notarizations, shouldnt be much at all!";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:19 PM";"just free up all the memory and not matter how long it runs, will just be 20 to 40 headers, even if a chain split";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:19 PM";"get to where you feel it is efficient as can be and will be able to handle actively being reorged";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:20 PM";"then we can test it on ILN";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:21 PM";"reorg detection should be as simple as detecting that the tiptime is not advancing";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:22 PM";"but I may be missing something";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:24 PM";"it is a reorg if a new height comes in that doesnt link back to the old chaintip";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:24 PM";"in this case, treat it like a new notarization came in and reset to the latest notarization and build the data from scratch";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:25 PM";"that way, no matter how deep the reorg. it will get back to the chaintip";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:25 PM";"certainly if many reorgs are happening, then this will be in a volatile state, but as soon as we get the next notarization, it all stabilizes";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:42 PM";"the problem with that is that, we dont know if its just that we are missing a block, or if the chain doesnt actually linkj though. 
I thaught about this for quite a long time.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:43 PM";"the solution I came up with was to just flag that the chain is either in sync or is not.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:43 PM";"if it wont link back, its not in sync. if it does then it is";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:50 PM";"unless all of your peers are on the wrong chain, it will eventually find the right one and flag its in sync";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 06:27 PM";"ok I have it working without gaps now. Once a notarization comes in,  it just stays in sync, without needing to fetch previous headers";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 12:17 AM";"https://github.com/blackjok3rtt/libnspv/tree/blackjok3r
Seems to work perfectly so far.";"";"üòç (1),labs1 (1)";
"455741312273219595";"jl777c#5810";"28-Jul-19 06:11 AM";"great job!";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 06:12 AM";"awaiting PR";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 06:14 AM";"with this, it seems the only thing left is adding CC support. starting with cross chain migrates. probably need to have a separate executable/thread and is coordinating multiple nspv instances. that gets chain cluster support to mobile";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 06:30 AM";"Still want to mess with it a bit more, Will make PR soon. Be good to test reorgs, as I cant really do that using KMD just running on tip.";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 07:20 AM";"use ILN";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 07:20 AM";"to test reorgs as it is notarized and low hashrate";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 07:21 AM";"no rush, this sort of thing it needs to be precise";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 10:42 AM";"Got node banning working üòÉ";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 10:42 AM";"Once it is synced, it checks the headers being sent are in the main chain, and if not after 10 bad headers removes the node.";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 10:43 AM";"There is one node that is sending garbage or NULL for the headers in getinfo, so it made it quite easy.";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 10:48 AM";"I think also I have the network code to remove peers who stop responding activated again.";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 12:52 PM";"probably some fullnode on an ancient version";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 12:52 PM";"there is also a version field returned with getinfo now, it is set to 1";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 12:52 PM";"anytime any of the strutures are changed, this will be changed and this allows to immediately detect an obsolete node";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 12:53 PM";"the other type would be a honest node, that is just not in sync yet. they can still provide useful info, so storing the height each node is at (many calls return that nodes height) and using that to filter height dependent requests";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 12:58 PM";"Problem is that height doesnt nessarily mean that its the same block as other peers.";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 01:02 PM";"If they dont send you a header at all, how can you validate that they are on the correct chain, you can only assume that hte blockhash they sent is correct";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 01:14 PM";"Pushed latest version, seems to be working very well for me, and should not crash  if there are no notarizations for over 100 blocks.";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 01:30 PM";"I assumed that they reson to keep track of the chain tip was to make sure you are only connected to nodes on the real chain. ?";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 01:30 PM";"@jl777c";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 01:34 PM";"with nSPV there really isnt that much need for it, but it is always nice to know which peers are on the chaintip and returning valid data";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 01:35 PM";"feel free to keep improving it, the nspv will set the standard for superlite clients, i think primarily as it is the first one that is more than a whitepaper";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 01:36 PM";"but might as well make it as good as we can so the best anybody else can do is be second with one that is not any better";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 01:39 PM";"https://github.com/jl777/libnspv/pull/25";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 01:42 PM";"Also, could the nSPV be used to validate the notarizaittion txid on the chain being notarized to?";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 01:42 PM";"Like just connect to some peers and pull the txid and validate it?";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 01:56 PM";"yes!";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 01:56 PM";"now that the single coin nspv is basically complete (other than CC)";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 01:56 PM";"we can move to all the cool things having multiple nspv instances active at once";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 01:57 PM";"the current design is just a single coin active, but most things are setup to be able to run multiple coins from a single instance";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 01:57 PM";"however it might be easier to make a different layer that uses multiple other nspv instances at the api level";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 01:58 PM";"ALL globals would need to be put into a globalvars structure and ALL functions that access any global will need to have the globals pointer passed into it to support multicoins in a single instance";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 01:58 PM";"ü§î";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 01:59 PM";"I dont think I habe anything else I need to do until the 2nd ... Maybe I will try this? Or should porting CC stuff be more important?";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:00 PM";"which way feels better?";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 02:00 PM";"Or should I go the iguana changes?";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 02:00 PM";"See if I can get delay working?";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:00 PM";"ah, just adding a big delay would solve the NN bickering";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:00 PM";"that shouldnt take long, so maybe get that out of the way";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:01 PM";"putting all globals in a globals structure and passing the globals pointer into all functions, it is just a lot of code changes, but nothing too difficult to do";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 02:01 PM";"One idea I had was to make it so that no nodes can receive any packets until the height has advanced one block past the block they agree on... That way its a fixed refernace point";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 02:02 PM";"could be avery long delay though";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:02 PM";"since we are validating notarizations for all utxo, the current chaintip is more a comfort thing";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:02 PM";"oh, for the notary side";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 02:02 PM";"yes sorry.";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:02 PM";"yes, can just delay by one block";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:02 PM";"something simple and brute force";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 02:03 PM";"Guess I'll have a look at that. I asked @Alright  to help me test reorgs on nSPV, so while waiting I will have a look at iguan see what I can work out.";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 02:04 PM";"Being able to have nSPV connect to multiple chains at once, seems a worthy thing to spend some time on though aswell.";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:06 PM";"yes";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:06 PM";"you understand the method that is needed to make nspv multicoin?";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 02:14 PM";"Kind of.";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:19 PM";"let me clarify";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:20 PM";"currently a specific coin is connected to a specific p2p network based on the chainparams";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:20 PM";"it then updates various global variables, mostly the NSPV_result structures";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:20 PM";"and now also the headers structures";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:21 PM";"so by making an all in one globals structure, like iguanas iguana_info struct";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:21 PM";"then all functions that update state of any global or even just need access to it must have a pointer to the right globals structure";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:22 PM";"the code can be transformed in place to have identical functionality, just with a globals structure allocated and passed to all functions";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:22 PM";"once that works, then a new ""addcoin"" api will then allow to dynamically add a new coin";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:23 PM";"once that is in place, then all the api calls would be done via each coins rpc port to determine which coin";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:23 PM";"but for things that span more than one coin, it would probably use a different port, or maybe use a ""coin"":""multi"" parameter";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:24 PM";"iguana basically does this multicoin handling";"";"";
"232679450301431808";"blackjok3r#3181";"28-Jul-19 02:25 PM";"Yes, I pretty much understand how iguana is doing it. Doenst seema huge diffrence here.";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:26 PM";"to get nspv working quickly, i used a lot of globals, so first step is to sweep all of them and i mean 100% all of them into a massive globals structure";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:26 PM";"and then pass the coins pointer to its globals down into each function that needs it and all global access goes through the globals pointer";"";"";
"455741312273219595";"jl777c#5810";"28-Jul-19 02:27 PM";"seems this will be a good practice for you to transform a codebase from a single instance to multiinstance capable";"";"";
