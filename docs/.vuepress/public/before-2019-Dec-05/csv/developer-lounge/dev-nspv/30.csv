AuthorID;Author;Date;Content;Attachments;Reactions;
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:42 AM";"getinfo stuff isnt validating the notarizations though right? just assumign the getinfo call has the right data?";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:43 AM";"getinfo just returns the raw data";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:43 AM";"yes so  how do wer know that the notarization we are trusting to tell us the chain is real?";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:43 AM";"for each notarization, you would want to do the notarization validation code";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:43 AM";"that likely needs to be a new api call";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:44 AM";"gettransaction does prevntz and nextntz";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:44 AM";"yea, in this case it can only do prev so that code doesnt work as is";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:44 AM";"it needs to be setup so you can validate just a single notarization";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:44 AM";"make a more surgical function that just validates a single notarization";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:44 AM";"understood";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:44 AM";"then the gettransaction can call it twice";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:45 AM";"the headers tracking just calls it once when it sees a new notarization";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:45 AM";"so the new api for validating a notarization, is just using the similar code to what is in gettransaction, then changing gettransaction to use that twice. that will not increase code";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:45 AM";"now there will be a function that validates a notarization in isolation";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:46 AM";"hdrheight is updated to get +1, +2, +3, ...";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:46 AM";"getinfo processing just updates the non-notarized blockhashes array";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:47 AM";"anything wonky, and reset to last notarization. that will deal with reorgs, but end in a meta (un)stable state when there is a competing fork, but in such cases best to not do tx anyway";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:47 AM";"at some point a new notarization comes in and it all starts over";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:47 AM";"so it is really a matter to process the chaintip for 10 to 20 blocks";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:49 AM";"it could be more than that at times, anyway I understand what to do now.";"";"";
"248918075922055168";"silence#0289";"27-Jul-19 05:49 AM";"https://tenor.com/view/tyrone-biggums-crackhead-drug-thirsty-itchy-gif-13961806";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:53 AM";"@blackjok3r i think if getinfo returned the number of times the non-notarized blockhashes array has been reset, it will give an indication if there is an active fork/attacker";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:53 AM";"you cant just make up an invalid blockheader, so that eliminates trusting the fullnode";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:54 AM";"there is an edgecase of notary mined blocks, which if needed we can validate did not mine more than once in the last 65 blocks";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 06:01 AM";"in any case, dont go too crazy with lots of code for this. we just need something simple to track the non-notarized chain. anybody doing large amounts should wait for everything to be notarized anyway, so it is more a detector for current chain conditions";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 09:00 AM";"I've got most of it working already, but the main limitation is that it currently requests the blocks in order, and as such pulls all of them from all nodes.
I had it so that it just pulled them all, but then they arrive out of order, and its much harder to sort them out.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 09:00 AM";"Also doing them all at once, some nodes return bad data or nothing and u end up with gaps.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 09:02 AM";"The main problem I see is on start up if there is no notarizations for like the last 20-30 blocks it takes quite a while to fill the array.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:45 AM";"just let it trickle in";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:45 AM";"one request per height";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:45 AM";"in a few minutes you will have all. i guess you need to cache the entire header, not just the hash, so you can hande things out of order";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:46 AM";"as long as each getinfo hdrheight is for a height you dont have, then you are getting numpeers*2 headers per minute";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:47 AM";"for getting a backlinked non-notarized chain a few minutes is fine. unless your utxo are notarized, it isnt notarized anyway, regardless of the state of the non-notarized chain";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:47 AM";"so only if you are doing non-notarized tx, then you would need the non-notarized blocks";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:48 AM";"nSPV is designed to scale to millions of users. having nodes blasting away to get optional data in a few seconds is not worth increasing the maxload";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:53 AM";"i dont understand this part ""as such pulls all of them from all nodes""";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:54 AM";"there is no need to get duplicates as long as the headers end up linking back to the notarization. so in NSPV_periodic, increment to the next height for each request, that will get a different one from each peer";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:54 AM";"once you get to the chaintip-1, set a flag that you made all the requests";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:55 AM";"if this flag is set, then on each NSPV_periodic, scan from the notarization to the first header that doesnt exist";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:56 AM";"separately, have a function that validates the backlinks, maybe when displaying the local getinfo result, you can just display the status of the headers array";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 09:56 AM";"before doing a non-notarized spend, then also use this to determine if we have all headers and it is reasonably safe";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 11:21 AM";"The problem is that it calls the same height from every node at the same time,  if you place the counter in the function that does the calls it will request them all , and then they arrive out of order, with headers missing.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 11:22 AM";"We can fetch them like this, but then we need to sort them and try and request missing ones, gets complicated.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 11:24 AM";"My understanding from your description was to just fetch them one at a time and store them in order, but is very slow and only uses the first response it gets, as all peers send the same thing";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 02:10 PM";"I think I have it pretty close now.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 03:40 PM";"they will return the value of hdrheight";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 03:41 PM";"just change the value you request for each peer, ie. have some shared global variable that increments each time a hdrheight is requested";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 03:41 PM";"then each peer will return a different height";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 03:41 PM";"you should be able to get it after the first batch";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 03:41 PM";"just on request, increment. dont wait for it to arrive";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 03:42 PM";"handle out of order by just copying the entire header to a headers[] array";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 03:42 PM";"separate out functions that validate the headers array";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 03:43 PM";"allocate the buffer where [0] is the most recent notarization, [1] is the next height, etc.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 03:43 PM";"dont worry about processing it on the fly, but if you do get a conflicting one, then maybe ignore it for now. most peers will send the correct value";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:59 PM";"I already have it working";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:00 PM";"https://github.com/blackjok3rtt/libnspv/commit/b05c0f6be504ade433da45fcffbd785225ac432c";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:00 PM";"shoul;d also handle reorgs just fine I think";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:01 PM";"almost impossible to validate the notarization without any data so I just made it count peers that agree before updating";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:01 PM";"seems very fast and appears to work fine so far";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:01 PM";"cant you validate the notarization with txproof and using how it is done in gettransaction?";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:02 PM";"being very fast is good";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:02 PM";"I gave to get the tx first lol, that data doestn exist";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:02 PM";"i guess we need to test reorg handling";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:02 PM";"I think it will work, but im not sure
Basically it just hashes hte blopck header, saves that along with the hashprevblock and height";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:04 PM";"I think I can optimize it a bit more stil, because on KMD it takes liek 10 blocks for a nota to be seen as valid, so all those blocks are lost and have to be fetched again when one comes in.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:04 PM";"what do you mean by ""I gave to get the tx first lol, that data doestn exist"" ?";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:04 PM";"dont you know the notarization txid";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:05 PM";"yes but I need to get the tx, which node to I get it from?";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:05 PM";"all of them?";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:05 PM";"just one is enough";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:05 PM";"you hash the raw tx data and if it matches the txid and it also has notarization opereturn data, it is a valid notarization";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:05 PM";"If all nodes agree the notariztion is valid what does it matter?";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:06 PM";"because by actually validating you can protect against an eclipse attack where all your peers are evil";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:06 PM";"you can validate a notarization 100% locally once you get the rawtxbytes";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:06 PM";"yes, but you can only fertch the tx from one of those peers 😄";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:06 PM";"so they can fke it";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:07 PM";"if they send an invalid raw hex, then it is rejected";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:07 PM";"what if they make one?";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:07 PM";"make one that is signed by all the notarize";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:07 PM";"notaries";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:07 PM";"🤔";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:07 PM";"did you look at the notarization valiation code?";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:07 PM";"yes, but its deep inside many functions";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:08 PM";"given the rawtx for a notarization, it validates it locally that it is a valid notarization";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:08 PM";"I need an easy way to fetch just the tx, but doesnt seem to be one";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:08 PM";"txproof";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:08 PM";"that gets the tx";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:08 PM";"txproof without height, gets only the rawtx";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:08 PM";"I looked at that... Guess I look again";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:08 PM";"with the height, it gets the rawtx and the txproof";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:08 PM";"but for notarization, we dont need the txproof";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:09 PM";"just the rawtx";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:09 PM";"it is selfcontained and validatable";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:09 PM";"ahah, I read the output of that RPC wrong.. .I thaught it was all 000 with no height, but it does have a txid";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:09 PM";"cool";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:10 PM";"NSPV_notarizationextract that calls the opretextract and fastnotaries count";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:10 PM";"yes I found all that easy enough. just needed the tx";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:10 PM";"you should just be able to setup to call NSPV_notarizationextract given the txproof ntztxid ht 0 returned valie";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:11 PM";"lets make nspv as streamlined and efficient as possible";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:11 PM";"it is so close to perfection";"";"";
