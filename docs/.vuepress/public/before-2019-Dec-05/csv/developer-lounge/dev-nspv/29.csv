AuthorID;Author;Date;Content;Attachments;Reactions;
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:20 AM";"this allows you to know the chain tip, and the last notarization";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:20 AM";"but not the blocks inbetween";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:20 AM";"what I needed to do was take the chain tip and validate the blockhash->prevblockhash back to the last notarization";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:21 AM";"I'm struggling to understand how that will work";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:21 AM";"I made it very badly, cant antually be used, but I needed something to experiment with to see what works and what doesnt. And basically, when you start to reqest a lot of blocks all peers get very mad at you and everything breaks";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:21 AM";"normal SPV can weed out bad peers by going ""oh look this peer has the most POW"" by just looking at headers";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:21 AM";"then assume any other peer with less POW is evil";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:22 AM";"we need the full block to do that with dpow, no?";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:22 AM";"or at least the notarizations";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:22 AM";"notarizations can be got with a very lightweight call, but it totally fails on chaintip, becaue there is no future notarization";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:23 AM";"Im really thinking it just cant really work on chain tip";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:23 AM";"how can you trust that a peer is showing you the latest notarization?";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:23 AM";"that's what I mean";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:24 AM";"by asking a whole bunch of them I think.... But thats really not seeming to be a working solution";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:24 AM";"It would require removing a whole heap of rate limiters and  weell... that is totaly stupid";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:26 AM";"yea I guess what I said doesn't really make sense";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:26 AM";"if you have at least 1 honest peer showing you latest, you're good?";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:26 AM";"same concept as SPV really";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:26 AM";"yes, you have all peers sending getinfo and latest headers..";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:27 AM";"but I cant get it to fetch blocks in reversee... There is data missing in the getinfo+headers call";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:28 AM";"So I had to make structures and loops and all kinds of stupid shit, to filter results and sort them and build the correct info by iterating in reverse";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:28 AM";"Slow as all fuck. doesnt work.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:28 AM";"Going to just change daemon";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:28 AM";"Cant work with these limitations";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:29 AM";"ðŸ¤”  lol just realised something";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:30 AM";"You can get the block hash fromt he header itself";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:30 AM";"ðŸ¤¦";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:30 AM";"Its not actually there";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:30 AM";"but you can hash it to get it";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:30 AM";"still don't understand what it is you're trying to do";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:30 AM";"wait i'll show you the problem";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:31 AM";"https://github.com/blackjok3rtt/libnspv/blob/master/src/tools/nSPV_superlite.h#L237";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:31 AM";"here";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:31 AM";"it doesnt validate anything, and if a reorg happens it cannot go in reverse";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:31 AM";"https://github.com/blackjok3rtt/libnspv/blob/master/src/tools/nSPV_superlite.h#L246
trying to fix what this comment says";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:32 AM";"I think Im just going to make it so that you have to wait until enough blocks arrive.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:32 AM";"Doesnt seem worth the100 hours work to reqwrite half of it to be able to request blocks from the past.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:33 AM";"All the tx shit works with past blocks already, not sure what the chain tip even does";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:33 AM";"need a much higher level explanation or I'll be no help ðŸ˜›";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:34 AM";"I cant explain it any mroe than that. Basically it needs:
` blockhash == hashprevblock`";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:34 AM";"but that cant work for a reorg so jl used heights only";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:35 AM";"`what I needed to do was take the chain tip and validate the blockhash->prevblockhash back to the last notarization` why?";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:35 AM";"you tell me thats what he asked me to do";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:36 AM";"getting off for the day, lmk what he says ðŸ˜„";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:37 AM";"not sure I understand, but it seems like you trust the notarization to tell you the chain is the correct chain, why would you need to validate blocks back to the previous notarization?";"";"";
"405011811511828481";"Alright#0419";"27-Jul-19 04:37 AM";"how does that help?";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:37 AM";"this is on chain tip, there is no notarizxation, only the last one you see,";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:37 AM";"dont need to go back another";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:58 AM";"ok I think I figured out how to do it. 
I need a hash table to stick the headers in. The block hash can be hashed from the header, there is a function already for this. Then it shuold be fast and easy to just iterate  backwards to the last notarization on each block header received.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:58 AM";"This seems the onyl viable way to be able to validate the headers nodes are sending you are real, while not destroying the network";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:59 AM";"This definally means though that a node will not know its on the right chain until it receives a notarized header.";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 04:59 AM";"unless I make a new API call.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:11 AM";"you are way overcomplicating this";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:12 AM";"given the chaintip height, just requests the getinfo for the 10 or so blocks to the most recent notarization";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:12 AM";"10 getinfo is not any large overhead";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:13 AM";"in fact, you are already making getinfo calls to all the peers, just with asking for the chaintip. so without any extra overhead you can get the most recent 10 headers via the getinfo calls you are doing anyway";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:13 AM";"why would this cause any performance issue? also each chain has about 10 seed nodes";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:18 AM";"so just change the hdrheight being requested on the background getinfo calls";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:18 AM";"then as they come in just calculate its blockhash and make sure its prev matches the blockhash of the prior block";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:19 AM";"i would start from the last notarization + 1, and just increment it until you reach the chain tip";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:20 AM";"then as it comes in you can validate that it connects to the notarization.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:20 AM";"just use a rotating buffer of 100 hashes or so to track the current mainchain.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:21 AM";"if you see a new height greater than chaintip that doesnt link back, then clear the rotating buffer and do it again, or you can be a bit more fancy and track multiple forks";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:23 AM";"when a new notarization comes in, reset the rotating buffer as we have the checkpoint";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:31 AM";"I did that and no nodes respond to me";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:32 AM";"this should not be a lot of code at all. just an incrementing variable for the hdrheight being requested";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:32 AM";"Maybe sending too many requests just breaks it I dont know";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:32 AM";"you are limited to 1 request per message per second per peer";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:32 AM";"if you have 10 peers, you can make 10 getinfo calls per second";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:33 AM";"find the place where it makes the getinfo requests already, just set the hdrheight to a useful one";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:34 AM";"on processing, just call an update header function that updates the buffer of recent blockhashes";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:34 AM";"The main issue is that its doing this validation inside the fuinction that processes repoonse, making new requests in there doesnt really work as it seems to spawn a new thread and everything gets messed up";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:34 AM";"it is tricky to make recursive requests";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:34 AM";"just update state when a new getinfo comes in";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:35 AM";"make it request a useful hdrheight in the getinfo calls it is already doing";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:35 AM";"Thats why I just wanted it to stick everything into some data stucture, I used and array and loops but its just too slow";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:35 AM";"you need to incrementally update state based on the new data that comes in";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:35 AM";"not trigger some brute force validation in the message completion function";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:36 AM";"that wont work";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:36 AM";"no it doesnt, but I needed to do something to understand how it all fit together. I think I get how it works now.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:36 AM";"yes";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:36 AM";"piggy back onto the getinfo requests that are already being made";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:37 AM";"then when a new header comes in, you just update the state of the recent headers";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:37 AM";"I tried to do that and failed badly. I reset all my code back to jl777 and starting agin, maybe I breoke it somwher along the line";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:37 AM";"once you catch up to chaintip, when the header for the next block comes in, you just need to make sure its prevhash is the prior block";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:38 AM";"if it isnt, then just reset to the most recent notarization";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:38 AM";"Need to work out how to make it request a particular header without iussueing new getinfo calls, because new getinfo calls just dont woirk, it will only make the ones it is already making";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:39 AM";"NSPV_periodic";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:39 AM";"maybe a global vector they can be pushed to and it just takes off the top with each request?";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:39 AM";"it is making reqht == 0 for all calls";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:39 AM";"yes it fetches tip each time";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:40 AM";"just make it request notarization height +1, +2, +3, ...";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:40 AM";"so this way there is a stream of useful new headers to update state. ZERO extra overhead";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:40 AM";"get that working first";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:40 AM";"ok I think I understand, now. Man i was over thinking it.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:40 AM";"then when you see the headers for +1, +2, +3,... chaintip then you will realize than a simple array is all that is needed in most all the cases";"";"";
"232679450301431808";"blackjok3r#3181";"27-Jul-19 05:41 AM";"Yea that makes sense. Store last notarized height and keep requesting all blocks from that height over and over until the next notarization then start again.";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:41 AM";"yes";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:41 AM";"and if a reorg happens, just clear to the prior notarization";"";"";
"455741312273219595";"jl777c#5810";"27-Jul-19 05:42 AM";"in the event to two competing forks, you will likely be resetting to notarization over and over. which is maybe a good signal to not do any tx as there is an active fork";"";"";
