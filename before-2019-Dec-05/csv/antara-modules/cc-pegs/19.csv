AuthorID;Author;Date;Content;Attachments;Reactions;
"455741312273219595";"jl777c#5810";"04-Dec-19 06:50 PM";"to make different nodes select different utxos, you can make them search the utxo list in a sorted order, offset by their msig id";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 06:51 PM";"so first msig node would scan offset 0, N, 2*N, ..., 1, N+1, 2*N+1, ...";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 06:51 PM";"That is not a problem, for now there is only one withdraw at a time processed.";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 06:51 PM";"what do you mean by ""sync the oraclfeed nodes so that there is no race condition""";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 06:51 PM";"But the problem is that for example the first sign that happens, 2 nodes take it at the same time and broadcast signtx. I want to sync them like that only one signs at the moment.";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 06:53 PM";"Before the first node that signed the tx broadcasted it to mempool and that tx reached 2nd node mempool, at that point other node thinks it needs to take the withdraw for signing.";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 06:53 PM";"use the same idea";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 06:53 PM";"each node gets a msig id";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 06:53 PM";"and each node only signs when the timestamp is id % N";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 06:54 PM";"Hmmm, nice...";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 06:54 PM";"maybe 1 second is too fast, as the tx needs to propagate, if so, you can make it 2 seconds";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 06:57 PM";"Yeah, so this would allow 30 nodes (which is enough) and each node can take id % N *2 second to process. Eventualy if some nodes are not live it could be that it will need 1 minute to sign it completely, but that is acceptable.";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 06:58 PM";"And I would use the time from komodo (GetTime()) to check ?";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:00 PM";"assume all msig signing nodes have done ntp recently so they are in sync to the millisecond";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:00 PM";"as long as each node can process multiple withdraws during their timeslot, it is all good";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:00 PM";"we get a pipelined signing process with minimal collisions";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:00 PM";"another way to avoid collisions is to add random sleeps";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:01 PM";"and make sure to update state often so if a node sees another node did something, it wont do anything to contradict it";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:01 PM";"Well, nodes will not process multiple withdraws as only one withdraw at the time is processed. But maybe we could expand it later with this idea to choose different utxos, and monitor which utxos are already used...";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:04 PM";"maybe a better way is to go as fast as possible, but wait for an earlier msig id to sign it";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:04 PM";"so at first second, msig.0 would be the only one that signs it";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:05 PM";"if he doesnt, then the next second msig,1 (and msig.0) are eligible to sign";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:05 PM";"etc.";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:05 PM";"once a single signature tx is seen, then the next msig.id is first to sign, the next second the next msig id is eligibile, etc.";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:06 PM";"i think a tx will get M signatures in close to N seconds";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:06 PM";"Yeah, maybe serialization is good. But how long should it wait until next msig.id takes for signing? msig.0 can be down...";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:07 PM";"1 second";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:07 PM";"if nothing appears, then msig.1 takes the lead";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:07 PM";"after 2 seconds if nothing, then msig.2 takes the lead";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:08 PM";"then 3, 4, 5, ... to N-M";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:08 PM";"that is for the first signature";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:08 PM";"then once there is a single signature tx in the mempool, the next msig.id has one second to sign and broadcast";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:08 PM";"if not, then first+2, first+3, ... to N-M-1";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:09 PM";"now we have a 2 signature tx, so the msig.second+1 is eligible the first timeslot";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:09 PM";"second is the msig.id of the second signer";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:13 PM";"Ok, but there is still a problem. If in 1st second msig.1 took the tx for signing and it broadcasted but it didn't propagate to msig.2 node in 2nd second msig.2 will take the initial withdraw to sign.";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:14 PM";"Basically if in 2 seconds it still doesn't propagate same will happen, but mostly it will be ok in 2 seconds.";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:21 PM";"msig.3 would see both and then only pick one of the two, so maybe it is not a big issue?";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:21 PM";"msig.2 would refrain from signing the first one, as it already signed it as the initial signer";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:21 PM";"Ohhh";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:21 PM";"Ok, get it";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:22 PM";"maybe there are some edge cases i dont see as this is just an intuitive design off the top of my head, but i think it should allow pretty decent practical performance";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:22 PM";"But it may be the issue with this. 1&2 sign the same and spend same input, 3 sees both and chooses 1, but 2 gets mined and 1 is invalid then...";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:23 PM";"if 1 and 2 sign the same one, then only one will be accepted by 3 into its mempool";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:23 PM";"also, if each node is choosing utxo in an interleaved fashion, they wouldnt be choosing the same utxo";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:24 PM";"let us imagine 1 and 2 both submit singly signed tx. now 3 will either accept 1 or 2, if it accepts 1, it will wait one second for 2 to sign it, but it wont happen and then it will sign it the next second";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:24 PM";"if it accepts 2, then it just immediately signs it";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:24 PM";"utxos cannot be chosen interleaved for siging. So when signing there is a marker which is spent in each signing iteration. So it must be serialezed.";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:25 PM";"ok";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:25 PM";"still the waiting for the signing time slot should resolve these tx signing forks";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:25 PM";"I think it may work. Let me try....";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:26 PM";"if 3 and 4 have the same issue, then msig.5 would choose between 1+3 or 2+3 or 1+4 and 2+4";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:26 PM";"oh, the same utxo can be accepted into all the mempools as it is a multisig";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:27 PM";"oh, its the mempool on the assetchain!";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:27 PM";"No, it is not a multisig. The signing is regular!";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:27 PM";"so you can have a baton to get mutual exclusion";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:27 PM";"There are two types of utxos. The external utxos, and AC utxos.";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:27 PM";"baton is basically marker";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:27 PM";"anyway, i think you have the idea of how to solve this now";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:27 PM";"Yes";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 07:27 PM";"let me know if anything comes up that makes it not work so well";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 07:28 PM";"I'll try it. Thnx";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 08:03 PM";"@jl777c BTW, @Alright put my attention to it. The N for MofN is now limitted to 15. Do we want to make it little bit more, like 30?";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:04 PM";"was thinking like a matrix of signers could work?";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:04 PM";"many b addresses";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 08:15 PM";"15 is the max that fits";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 08:15 PM";"practically speaking 7 of 13 signers should be sufficient";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:16 PM";"can't scale it up with additional multisigs?";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:16 PM";"7 nodes down at once doesn't seem unlikely";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:16 PM";"especially if purposefully taken down";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 08:17 PM";"when they come back up, it should process whatever was missed";"";"";
"455741312273219595";"jl777c#5810";"04-Dec-19 08:17 PM";"finding 30 long term reliable operators will be a lot harder than 13";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:19 PM";"keep them behind tor if possible 😅";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 08:22 PM";"Signers will be notary opreators.";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:51 PM";"not saying this is at all practical, just a bit curious about the math behind it now that I'm thinking about it. Given for example 60 signers, there are 386206920 subsets of 7 signers. Obviously you couldn't have this amount of addresses, but I'm trying to figure out how much more ""coverage""(not sure what the term would be) we could get by having say 10 deposit multisigs.";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 08:54 PM";"I don't get why you keep thinking about multiple msgi addresses? For one set of pubkeys you have one address. You don't get anything by having more addresses, it is still the same pubkeys.
What is your concern about 15 signers exactly?";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:54 PM";"Am just brain storming, will take it elsewhere if you don't want to hear it";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:55 PM";"again, `not saying this is at all practical` literally just curious about this math problem";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 08:56 PM";"`but I'm trying to figure out how much more ""coverage"" we could get by having say 10 deposit multisigs.`
What you mean by this?";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:56 PM";"so with 386206920 total addreses, any 7/60 could sign, this would be 100% ""coverage""";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:56 PM";"sorry, I know that's confusing 🤣";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 08:57 PM";"Don't get `any 7/60 can sign`. Now also any 7/60 could sign (if N could be 60)";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:57 PM";"eh never mind, don't let me waste your time";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 08:58 PM";"I'm just checking if you didn't maybe get something right so you are thinking in wrong direction.";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 08:58 PM";"it's not relevant";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 08:58 PM";"That is why I asked what is your concern exactly";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 09:03 PM";"to be frank, the concern would be the gateway going defunct. I know it's unlikely to happen given the signers, but I wouldn't want to hold coins on these chains for anything but short term";"";"";
"412323938782150658";"SHossain#0007";"04-Dec-19 09:04 PM";"as of today i have collected 7 pubkeys from signers for the test phase. once we have parallel processing ready and initially tested, we can ask them to setup node for testing.";"";"";
"412323938782150658";"SHossain#0007";"04-Dec-19 09:04 PM";"i guess others will submit their keys too soon";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 09:04 PM";"so was just brain storming on how it might be possible to decrease point of failures(signers)";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 09:05 PM";"Increasing point of failures can be just with bigger N (more different pubkeys and nodes).";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 09:05 PM";"yes, but 15 is a hard limit unless we hack script code";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 09:05 PM";"Jl is right though, 7of15 is practical and will work";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 09:06 PM";"I can increase the limit to 10000. But the gateways that will be setup for now will have 13 signers.";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 09:06 PM";"6of13";"";"";
"412323938782150658";"SHossain#0007";"04-Dec-19 09:06 PM";"7 of 13";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 09:06 PM";"Yes";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 09:06 PM";"sorry";"";"";
"405011811511828481";"Alright#0419";"04-Dec-19 09:06 PM";"why 13 not 15?";"";"";
"424224648889106444";"Mihailo#5902";"04-Dec-19 09:06 PM";"That is not a question for me 😉";"";"";
